name: Deploy to AWS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Manual trigger

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_WEB: clip-it-web
  ECR_REPOSITORY_WORKER: clip-it-worker
  ECS_SERVICE_WEB: clip-it-web-service
  ECS_SERVICE_WORKER: clip-it-gpu-worker-service
  ECS_CLUSTER: clip-it-cluster
  ECS_TASK_DEFINITION_WEB: clip-it-web-task
  ECS_TASK_DEFINITION_WORKER: clip-it-worker-task
  CONTAINER_NAME_WEB: clip-it-web
  CONTAINER_NAME_WORKER: clip-it-worker

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    environment: production
    concurrency:
      group: deploy-aws
      cancel-in-progress: false  # Don't cancel, wait for previous to complete

    steps:
    - name: Checkout
      uses: actions/checkout@v4
 
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install AWS CDK
      run: npm install -g aws-cdk

    - name: Deploy Infrastructure
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
        JSII_SILENCE_WARNING_DEPRECATED_NODE_VERSION: 1
        SSL_CERTIFICATE_ARN: ${{ secrets.SSL_CERTIFICATE_ARN }}
      run: |
        echo "üèóÔ∏è Deploying infrastructure..."
        cd infrastructure
        pip install -r requirements.txt
        
        # Get AWS Account ID
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "AWS Account ID: $AWS_ACCOUNT_ID"
        
        # Always update CDK bootstrap to latest version
        echo "üîß Updating CDK bootstrap to latest version..."
        cdk bootstrap aws://$AWS_ACCOUNT_ID/$AWS_DEFAULT_REGION --force --require-approval never || {
          echo "‚ö†Ô∏è Bootstrap update failed, continuing with existing bootstrap..."
        }
        
        # Get SSL certificate ARN from SSM (if available)
        echo "üîç Checking for SSL certificate..."
        SSL_CERT_ARN=$(aws ssm get-parameter \
          --name "/clip-it/ssl-certificate-arn" \
          --region $AWS_DEFAULT_REGION \
          --query "Parameter.Value" \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$SSL_CERT_ARN" ]; then
          echo "‚úÖ Found SSL certificate ARN: $SSL_CERT_ARN"
          export SSL_CERTIFICATE_ARN="$SSL_CERT_ARN"
        else
          echo "‚ö†Ô∏è  No SSL certificate found in SSM. Deploying with HTTP only."
        fi
        
        # Check for and handle stuck changesets
        echo "üîç Checking for stuck CloudFormation changesets..."
        STACK_NAME="ClipItStack"
        CHANGESET_NAME=$(aws cloudformation list-change-sets \
          --stack-name $STACK_NAME \
          --region $AWS_DEFAULT_REGION \
          --query "Summaries[?Status=='CREATE_IN_PROGRESS' || Status=='CREATE_PENDING'].ChangeSetName" \
          --output text 2>/dev/null || echo "")
        
        if [ ! -z "$CHANGESET_NAME" ]; then
          echo "‚ö†Ô∏è Found stuck changeset: $CHANGESET_NAME"
          echo "‚è≥ Waiting for changeset to complete or timeout (max 5 minutes)..."
          
          # Wait for changeset to complete or timeout
          TIMEOUT=300  # 5 minutes
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(aws cloudformation describe-change-set \
              --stack-name $STACK_NAME \
              --change-set-name $CHANGESET_NAME \
              --region $AWS_DEFAULT_REGION \
              --query "Status" \
              --output text 2>/dev/null || echo "NOT_FOUND")
            
            if [ "$STATUS" == "CREATE_COMPLETE" ] || [ "$STATUS" == "FAILED" ] || [ "$STATUS" == "NOT_FOUND" ]; then
              echo "‚úÖ Changeset status: $STATUS"
              break
            fi
            
            echo "‚è≥ Changeset still in progress (status: $STATUS), waiting 10 seconds..."
            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done
          
          # If still stuck, try to delete it (only if it's in a deletable state)
          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "‚ö†Ô∏è Changeset still stuck after timeout, attempting to delete..."
            aws cloudformation delete-change-set \
              --stack-name $STACK_NAME \
              --change-set-name $CHANGESET_NAME \
              --region $AWS_DEFAULT_REGION 2>/dev/null || {
              echo "‚ö†Ô∏è Could not delete changeset (may need manual intervention)"
            }
          fi
        else
          echo "‚úÖ No stuck changesets found"
        fi
        
        # Deploy the infrastructure with retry logic
        echo "üöÄ Deploying ClipItStack..."
        MAX_RETRIES=3
        RETRY_COUNT=0
        DEPLOY_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DEPLOY_SUCCESS" = false ]; do
          if [ $RETRY_COUNT -gt 0 ]; then
            echo "üîÑ Retry attempt $RETRY_COUNT of $MAX_RETRIES..."
            sleep $((RETRY_COUNT * 10))  # Exponential backoff
          fi
          
          if cdk deploy --require-approval never --outputs-file outputs.json; then
            DEPLOY_SUCCESS=true
            echo "‚úÖ Infrastructure deployed successfully!"
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "‚ö†Ô∏è Deployment failed, will retry..."
              # Clean up any new stuck changesets before retry
              sleep 5
            else
              echo "‚ùå Deployment failed after $MAX_RETRIES attempts"
              exit 1
            fi
          fi
        done

    - name: Login to Amazon ECR
      id: login-ecr
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push web image to Amazon ECR
      id: build-web-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build web image
        docker build -f Dockerfile.web -t $ECR_REGISTRY/$ECR_REPOSITORY_WEB:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_WEB:$IMAGE_TAG
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_WEB:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_WEB:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_WEB:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_WEB:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Build, tag, and push worker image to Amazon ECR
      id: build-worker-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build worker image
        docker build -f Dockerfile.worker -t $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:$IMAGE_TAG
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_WORKER:latest
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY_WORKER:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Download task definition
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_WEB --query taskDefinition > task-definition-web.json
        aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION_WORKER --query taskDefinition > task-definition-worker.json

    - name: Fill in the new image ID in the Amazon ECS task definition (web)
      id: task-def-web
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition-web.json
        container-name: ${{ env.CONTAINER_NAME_WEB }}
        image: ${{ steps.build-web-image.outputs.image }}

    - name: Fill in the new image ID in the Amazon ECS task definition (worker)
      id: task-def-worker
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition-worker.json
        container-name: ${{ env.CONTAINER_NAME_WORKER }}
        image: ${{ steps.build-worker-image.outputs.image }}

    - name: Start ECS Services and Scale ASG
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      run: |
        echo "üöÄ Starting ECS services..."
        
        # Explicitly scale up GPU ASG to 1 to speed up deployment
        # The ASG name contains a random string, so we find it by prefix
        ASG_NAME=$(aws autoscaling describe-auto-scaling-groups --query "AutoScalingGroups[?starts_with(AutoScalingGroupName, 'ClipItStack-GPUWorkerASG')].AutoScalingGroupName" --output text)
        if [ ! -z "$ASG_NAME" ]; then
          echo "üìà Scaling up ASG: $ASG_NAME"
          aws autoscaling set-desired-capacity --auto-scaling-group-name "$ASG_NAME" --desired-capacity 1
        fi

        aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE_WEB }} --desired-count 1
        aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE_WORKER }} --desired-count 1
        echo "‚úÖ ECS services started and ASG scaling requested"

    - name: Deploy Amazon ECS task definition (web)
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def-web.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_WEB }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true

    - name: Deploy Amazon ECS task definition (worker)
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def-worker.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE_WORKER }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
        wait-for-minutes: 30  # Further increase stability timeout for GPU driver/image pulls

    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Deployment successful!"
          echo "Web service: ${{ env.ECS_SERVICE_WEB }}"
          echo "Worker service: ${{ env.ECS_SERVICE_WORKER }}"
        else
          echo "‚ùå Deployment failed!"
        fi
